import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:intl/intl.dart';

class ExpensesAnalyticsDatabase {
  final CollectionReference _records =
      FirebaseFirestore.instance.collection('ServiceRecord');

  /// Returns summary by selected duration:
  /// 'DAYS'  -> group by day (Mon..Sun) for current week
  /// 'MONTHS'-> group by week (Week 1..Week N) for current month
  /// 'YEARS' -> group by month (Jan..Dec) for current year
Future<Map<String, dynamic>> fetchExpenseSummary({
  required String userId,
  required String duration,
}) async {
  final snapshot =
      await _records.where('userId', isEqualTo: userId).get();

  final now = DateTime.now();
  final Map<String, double> groupedTotals = {};

  // Define time range boundaries
  late DateTime startDate;
  late DateTime endDate;

  if (duration == 'DAYS') {
    // current week Monday..Sunday
    startDate = now.subtract(Duration(days: now.weekday - 1));
    endDate = startDate.add(const Duration(days: 6));
  } else if (duration == 'MONTHS') {
    // current month
    startDate = DateTime(now.year, now.month, 1);
    endDate = DateTime(now.year, now.month + 1, 0);
  } else {
    // current year
    startDate = DateTime(now.year, 1, 1);
    endDate = DateTime(now.year, 12, 31);
  }

  for (final doc in snapshot.docs) {
    final data = doc.data() as Map<String, dynamic>;
    final amount = _parseDouble(data['amount']);

    // Parse 'date' string
    DateTime? date;
    final rawDate = data['date'];
    if (rawDate is String && rawDate.isNotEmpty) {
      try {
        date = DateFormat('yyyy-MM-dd').parse(rawDate);
      } catch (_) {}
    }
    if (date == null) continue;

    // âœ… Only include entries within the target date range
    if (date.isBefore(startDate) || date.isAfter(endDate)) continue;

    late String key;
    if (duration == 'DAYS') {
      key = DateFormat('E').format(date); // Mon, Tue, ...
    } else if (duration == 'MONTHS') {
      final weekNumber = ((date.day - 1) / 7).floor() + 1; // 1..5
      key = 'Week $weekNumber';
    } else {
      key = DateFormat('MMM').format(date); // Jan, Feb, ...
    }

    groupedTotals[key] = (groupedTotals[key] ?? 0.0) + amount;
  }

  // Fill missing labels
  if (duration == 'DAYS') {
    for (final d in ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']) {
      groupedTotals.putIfAbsent(d, () => 0.0);
    }
  } else if (duration == 'MONTHS') {
    final daysInMonth = DateTime(now.year, now.month + 1, 0).day;
    final weeksInMonth = ((daysInMonth - 1) ~/ 7) + 1;
    for (var i = 1; i <= weeksInMonth; i++) {
      groupedTotals.putIfAbsent('Week $i', () => 0.0);
    }
  } else {
    for (final m in [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ]) {
      groupedTotals.putIfAbsent(m, () => 0.0);
    }
  }

  // âœ… Now compute total & average only from filtered data
  final total = groupedTotals.values.fold(0.0, (a, b) => a + b);

  final bucketCount = duration == 'DAYS'
      ? 7
      : duration == 'MONTHS'
          ? ((DateTime(now.year, now.month + 1, 0).day - 1) ~/ 7) + 1
          : 12;

  final average = bucketCount > 0 ? total / bucketCount : 0.0;
  final tco = average * 6; // predictive TCO (6 months assumption)

  // Sort logically
  final sortedKeys = groupedTotals.keys.toList()
    ..sort((a, b) {
      if (duration == 'DAYS') {
        const order = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
        return order.indexOf(a).compareTo(order.indexOf(b));
      } else if (duration == 'MONTHS') {
        final ai = int.tryParse(a.replaceAll('Week ', '')) ?? 0;
        final bi = int.tryParse(b.replaceAll('Week ', '')) ?? 0;
        return ai.compareTo(bi);
      } else {
        const months = {
          'Jan': 1, 'Feb': 2, 'Mar': 3, 'Apr': 4, 'May': 5, 'Jun': 6,
          'Jul': 7, 'Aug': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dec': 12
        };
        return (months[a] ?? 0).compareTo(months[b] ?? 0);
      }
    });

  final sortedMap = {for (var k in sortedKeys) k: groupedTotals[k]!};

  return {
    'total': total,
    'groupedTotals': sortedMap,
    'average': average,
    'tco': tco,
  };
}


      /// ðŸ”® Predicts future total cost (TCO) for next 6 months
  /// based on historical monthly spending trend.
  ///
  /// Uses linear regression on monthly totals from the past 6â€“12 months.
  /// Returns:
  /// {
  ///   'predictedTotal': double,
  ///   'monthlyProjection': [double, double, ...] (next 6 months)
  /// }
Future<Map<String, dynamic>> predictTCO({
  required String userId,
}) async {
  final snapshot =
      await _records.where('userId', isEqualTo: userId).get();

  // Step 1: Build monthly totals (last 12 months)
  final Map<String, double> monthlyTotals = {};
  for (final doc in snapshot.docs) {
    final data = doc.data() as Map<String, dynamic>;
    final amount = _parseDouble(data['amount']);

    DateTime? date;
    final rawDate = data['date'];
    if (rawDate is String && rawDate.isNotEmpty) {
      try {
        date = DateFormat('yyyy-MM-dd').parse(rawDate);
      } catch (_) {}
    } else if (rawDate is Timestamp) {
      date = rawDate.toDate();
    } else if (data['createdAt'] is Timestamp) {
      date = (data['createdAt'] as Timestamp).toDate();
    }
    if (date == null) continue;

    final key = DateFormat('yyyy-MM').format(date);
    monthlyTotals[key] = (monthlyTotals[key] ?? 0) + amount;
  }

  if (monthlyTotals.isEmpty) {
    return {
      'predictedTotal': 0.0,
      'monthlyProjection': List.filled(6, 0.0),
    };
  }

  // Step 2: Sort months chronologically
  final sortedKeys = monthlyTotals.keys.toList()
    ..sort((a, b) => a.compareTo(b));
  final values = sortedKeys.map((k) => monthlyTotals[k]!).toList();

  // Limit to last 12 months if more data exists
  final recentValues = values.length > 12
      ? values.sublist(values.length - 12)
      : values;

  // Step 3: Linear regression (y = a + b*x)
  final n = recentValues.length;
  final xVals = List.generate(n, (i) => i + 1);
  final xMean = xVals.reduce((a, b) => a + b) / n;
  final yMean = recentValues.reduce((a, b) => a + b) / n;

  double numerator = 0.0;
  double denominator = 0.0;
  for (int i = 0; i < n; i++) {
    numerator += (xVals[i] - xMean) * (recentValues[i] - yMean);
    denominator += (xVals[i] - xMean) * (xVals[i] - xMean);
  }

  final slope = denominator == 0 ? 0.0 : numerator / denominator;
  final intercept = yMean - slope * xMean;

  // Step 4: Predict next 6 months
  final List<double> predictions = [];
  for (int i = n + 1; i <= n + 6; i++) {
    final y = intercept + slope * i;
    predictions.add(y < 0 ? 0.0 : y);
  }

  final predictedTotal =
      predictions.fold(0.0, (a, b) => a + b);

  return {
    'predictedTotal': predictedTotal,
    'monthlyProjection': predictions,
  };
}

  /// Returns a Map<Category, sumAmount> filtered by duration (so pie updates properly)
  Future<Map<String, double>> fetchExpensesByCategory({
    required String userId,
    required String duration,
  }) async {
    final snapshot =
        await _records.where('userId', isEqualTo: userId).get();

    final Map<String, double> map = {};
    final now = DateTime.now();

    for (final doc in snapshot.docs) {
      final data = doc.data() as Map<String, dynamic>;
      final category = (data['category'] ?? 'Unknown').toString();
      final amount = _parseDouble(data['amount']);

      DateTime? date;
      final rawDate = data['date'];
      if (rawDate is String && rawDate.isNotEmpty) {
        try {
          date = DateFormat('yyyy-MM-dd').parse(rawDate);
        } catch (_) {}
      } else if (rawDate is Timestamp) {
        date = rawDate.toDate();
      } else if (data['createdAt'] is Timestamp) {
        date = (data['createdAt'] as Timestamp).toDate();
      }
      if (date == null) continue;

      bool include = false;
      if (duration == 'DAYS') {
        final startOfWeek = now.subtract(Duration(days: now.weekday - 1));
        final endOfWeek = startOfWeek.add(const Duration(days: 6));
        include = !date.isBefore(startOfWeek) && !date.isAfter(endOfWeek);
      } else if (duration == 'MONTHS') {
        include = date.year == now.year && date.month == now.month;
      } else {
        include = date.year == now.year;
      }

      if (!include) continue;
      map[category] = (map[category] ?? 0.0) + amount;
    }

    return map;
  }

  double _parseDouble(dynamic v) {
    if (v == null) return 0.0;
    if (v is num) return v.toDouble();
    if (v is String) return double.tryParse(v) ?? 0.0;
    return 0.0;
  }
}
