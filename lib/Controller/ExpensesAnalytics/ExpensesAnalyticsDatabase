import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:intl/intl.dart';

class ExpensesAnalyticsDatabase {
  final CollectionReference _records =
      FirebaseFirestore.instance.collection('ServiceRecord');

  /// Returns summary by selected duration:
  /// 'DAYS' -> group by day
  /// 'MONTHS' -> group by month
  /// 'YEARS' -> group by year
  Future<Map<String, dynamic>> fetchExpenseSummary({
  required String userId,
  required String duration,
}) async {
  final snapshot =
      await _records.where('userId', isEqualTo: userId).get();

  double total = 0.0;
  final Map<String, double> groupedTotals = {};

  final now = DateTime.now();

  for (final doc in snapshot.docs) {
    final data = doc.data() as Map<String, dynamic>;
    final amount = _parseDouble(data['amount']);

    DateTime date;
    final rawDate = data['date'];
    if (rawDate is String && rawDate.isNotEmpty) {
      try {
        date = DateFormat('yyyy-MM-dd').parse(rawDate);
      } catch (_) {
        continue;
      }
    } else if (rawDate is Timestamp) {
      date = rawDate.toDate();
    } else {
      continue;
    }

    total += amount;

    late String key;

    if (duration == 'DAYS') {
      // Show current week (Mon–Sun)
      final startOfWeek =
          now.subtract(Duration(days: now.weekday - 1)); // Monday
      final endOfWeek = startOfWeek.add(const Duration(days: 6));

      if (date.isBefore(startOfWeek) || date.isAfter(endOfWeek)) continue;

      final weekdayName = DateFormat('E').format(date); // Mon, Tue, etc.
      key = weekdayName;
    } else if (duration == 'MONTHS') {
      // Show current month, group by week number
      if (date.year != now.year || date.month != now.month) continue;

      final weekNumber = ((date.day - 1) / 7).floor() + 1;
      key = 'Week $weekNumber';
    } else {
      // YEARS → show current year grouped by month
      if (date.year != now.year) continue;

      key = DateFormat('MMM').format(date); // Jan, Feb, ...
    }

    groupedTotals[key] = (groupedTotals[key] ?? 0) + amount;
  }

  // Fill in missing periods (for empty days/weeks/months)
  if (duration == 'DAYS') {
    for (final d in ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']) {
      groupedTotals.putIfAbsent(d, () => 0);
    }
  } else if (duration == 'MONTHS') {
    for (var i = 1; i <= 5; i++) {
      groupedTotals.putIfAbsent('Week $i', () => 0);
    }
  } else {
    for (final m in [
      'Jan',
      'Feb',
      'Mar',
      'Apr',
      'May',
      'Jun',
      'Jul',
      'Aug',
      'Sep',
      'Oct',
      'Nov',
      'Dec'
    ]) {
      groupedTotals.putIfAbsent(m, () => 0);
    }
  }

  // Compute average and TCO
  final average = groupedTotals.isEmpty
      ? 0.0
      : groupedTotals.values.reduce((a, b) => a + b) /
          groupedTotals.length;

  final tco = average * 6; // simple projection

  return {
    'total': total,
    'groupedTotals': groupedTotals,
    'average': average,
    'tco': tco,
  };
}


  /// Returns a Map<Category, sumAmount>
  Future<Map<String, double>> fetchExpensesByCategory({
    required String userId,
  }) async {
    final snapshot = await _records.where('userId', isEqualTo: userId).get();
    final Map<String, double> map = {};

    for (final doc in snapshot.docs) {
      final data = doc.data() as Map<String, dynamic>;
      final category = (data['category'] ?? 'Unknown').toString();
      final amount = _parseDouble(data['amount']);
      map[category] = (map[category] ?? 0.0) + amount;
    }
    return map;
  }

  double _parseDouble(dynamic v) {
    if (v == null) return 0.0;
    if (v is num) return v.toDouble();
    if (v is String) return double.tryParse(v) ?? 0.0;
    return 0.0;
  }
}
